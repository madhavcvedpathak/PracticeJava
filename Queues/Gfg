//Reverse first K of a Queue
public Queue<Integer> reverseFirstK(Queue<Integer> q, int k) {
    if (q == null || k > q.size() || k < 0) return q;
    
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < k; i++) { // Step 1: Push first k elements into stack
        stack.push(q.remove());
    }
    while (!stack.isEmpty()) { // Step 2: Enqueue stack elements back to queue
        q.add(stack.pop());
    }
    int size = q.size(); // Step 3: Move the rest (size - k) elements to the back to maintain order
    for (int i = 0; i < size - k; i++) {
        q.add(q.remove());
    }
    return q;
}


//1823. Find the Winner of the Circular Game
public int findTheWinner(int n, int k) {
    Queue<Integer> q = new LinkedList<>();
    // Fill the queue with friends 1 to n
    for (int i = 1; i <= n; i++) {
        q.add(i);
    }
    while (q.size() > 1) {
        for (int i = 1; i < k; i++) { // Move first (k - 1) friends to the back
            q.add(q.remove());
        }
        q.remove(); // Eliminate the k-th friend
    }
    return q.peek(); // The last person is the winner
}


//Queue using Linked List
class MyQueue {
    QueueNode front, rear;
    void push(int a) {
        QueueNode newNode = new QueueNode(a);
        if (rear == null) { // Queue is empty
            front = rear = newNode;
        } else { // Add at rear
            rear.next = newNode;
            rear = newNode;
        }
    }
    int pop() {
        if (front == null) { // Queue is empty
            return -1;
        }
        int val = front.data;
        front = front.next;
        if (front == null) { // If queue becomes empty after pop
            rear = null;
        }
        return val;
    }
}

//225. Implement Stack using Queues
class MyStack {
    private Queue<Integer> q = new LinkedList<>();

    public MyStack() {
    }

    public void push(int x) {
        q.add(x); // Add element normally
        int size = q.size();
        // Rotate the queue to move the new element to the front
        for (int i = 0; i < size - 1; i++) {
            q.add(q.remove());
        }
    }

    public int pop() {
        if (q.isEmpty()) return -1; // or throw exception
        return q.remove();
    }

    public int top() {
        if (q.isEmpty()) return -1;
        return q.peek();
    }

    public boolean empty() {
        return q.isEmpty();
    }
}


//232. Implement Queue using Stacks
class MyQueue {
    private Stack<Integer> stack1 = new Stack<>();
    private Stack<Integer> stack2 = new Stack<>();

    public MyQueue() {
        // Constructor
    }

    public void push(int x) {
        // Move all elements back to stack1 before pushing new element
        while (!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }
        stack1.push(x);
    }

    // Returns -1 if empty instead of throwing exception
    public int pop() {
        if (empty()) {
            System.out.println("Queue is empty. Cannot pop.");
            return -1;
        }
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }

    // Returns -1 if empty instead of throwing exception
    public int peek() {
        if (empty()) {
            System.out.println("Queue is empty. Nothing to peek.");
            return -1;
        }
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }

    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }
}


//Interleave the First Half of the Queue with Second Half
public Queue<Integer> rearrangeQueue(Queue<Integer> q) {
    int n = q.size();
    Stack<Integer> stack = new Stack<>();

    // Step 1: Push first half elements into stack
    for (int i = 0; i < n / 2; i++) {
        stack.push(q.remove());
    }

    // Step 2: Add stack elements back to queue to restore order
    while (!stack.isEmpty()) {
        q.add(stack.pop());
    }

    // Step 3: Move first half elements to the back of queue
    for (int i = 0; i < n / 2; i++) {
        q.add(q.remove());
    }

    // Step 4: Push first half elements into stack again for interleaving
    for (int i = 0; i < n / 2; i++) {
        stack.push(q.remove());
    }

    // Step 5: Interleave stack and queue elements
    while (!stack.isEmpty()) {
        q.add(stack.pop());  // from first half
        q.add(q.remove());   // from second half
    }

    return q;
}

OR

public Queue<Integer> rearrangeQueue(Queue<Integer> q) { // TWO QUEUE APPROACH
    int n = q.size();
    Queue<Integer> q1 = new LinkedList<>();

    // Step 1: Move first half elements from q to q1
    for (int i = 0; i < n / 2; i++) {
        q1.add(q.remove());
    }

    // Step 2: Interleave elements from q1 and q back to q
    while (!q1.isEmpty()) {
        q.add(q1.remove());  // from first half
        q.add(q.remove());   // from second half
    }

    return q;
}

OR

public Queue<Integer> rearrangeQueue(Queue<Integer> q) { // ONE STACK APPROACH
    int n = q.size();
    Stack<Integer> stack = new Stack<>();

    for (int i = 0; i < n / 2; i++) {
        stack.push(q.remove());
    }

    while (!stack.isEmpty()) {
        q.add(stack.pop());
    }

    for (int i = 0; i < n / 2; i++) {
        q.add(q.remove());
    }

    for (int i = 0; i < n / 2; i++) {
        stack.push(q.remove());
    }

    while (!stack.isEmpty()) {
        q.add(stack.pop());
        q.add(q.remove());
    }

    return q;
}


//First negative in every window of size k
static List<Integer> firstNegInt(int arr[], int k) {
    List<Integer> ans = new ArrayList<>();
    int n = arr.length;
    Queue<Integer> q = new LinkedList<>();

    // Step 1: enqueue indices of all negative numbers
    for (int i = 0; i < n; i++) {
        if (arr[i] < 0) q.add(i);
    }

    // Step 2: slide window
    for (int i = 0; i <= n - k; i++) {
        // Remove indices out of this window
        while (!q.isEmpty() && q.peek() < i) {
            q.poll();
        }

        // Add first negative in current window, or 0 if none
        if (!q.isEmpty() && q.peek() < i + k) {
            ans.add(arr[q.peek()]);
        } else {
            ans.add(0);
        }
    }
    return ans;
}